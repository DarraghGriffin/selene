use chrono::Local;
use color_eyre::eyre::Context;
use std::{collections::BTreeMap, io::Write};

use super::api::*;
use selene_lib::standard_library::*;

const API_DUMP: &str =
    "https://raw.githubusercontent.com/CloneTrooper1019/Roblox-Client-Tracker/roblox/API-Dump.json";

pub struct RobloxGenerator {
    pub std: StandardLibrary,
    pub show_deprecated: bool,
}

impl RobloxGenerator {
    pub fn generate(mut self) -> color_eyre::Result<(Vec<u8>, StandardLibrary)> {
        let api: ApiDump = ureq::get(API_DUMP)
            .call()
            .context("error when getting API dump")?
            .into_json()
            .context("error when parsing API dump")?;

        self.write_class(&api, "game", "DataModel");
        self.write_class(&api, "plugin", "Plugin");
        self.write_class(&api, "script", "Script");
        self.write_class(&api, "workspace", "Workspace");

        self.write_enums(&api);
        self.write_instance_new(&api);
        self.write_get_service(&api);

        self.deprecated_event_methods();

        let mut bytes = Vec::new();

        let time = Local::now();
        self.std.last_updated = Some(time.timestamp());

        writeln!(
            bytes,
            "# This file was @generated by generate-roblox-std at {time}",
        )?;

        write!(bytes, "{}", serde_yaml::to_string(&self.std)?)?;

        self.std
            .extend(StandardLibrary::from_name(self.std.base.as_ref().unwrap()).unwrap());

        Ok((bytes, self.std))
    }

    pub fn base_std() -> StandardLibrary {
        serde_yaml::from_str(include_str!("./base.yml"))
            .expect("Roblox base.yml was an invalid standard library")
    }

    fn write_class(&mut self, api: &ApiDump, global_name: &str, class_name: &str) {
        self.write_class_struct(api, class_name);
        self.std.globals.insert(
            global_name.to_owned(),
            Field::from_field_kind(FieldKind::Struct(class_name.to_owned())),
        );
    }

    fn write_class_struct(&mut self, api: &ApiDump, class_name: &str) {
        let structs = &mut self.std.structs;
        if structs.contains_key(class_name) {
            return;
        }

        structs.insert(class_name.to_owned(), BTreeMap::new());

        let mut table = BTreeMap::new();
        table.insert(
            "*".to_owned(),
            Field::from_field_kind(FieldKind::Struct("Instance".to_owned())),
        );

        self.write_class_members(api, &mut table, class_name);

        self.std.structs.insert(class_name.to_owned(), table);
    }

    fn write_class_members(
        &mut self,
        api: &ApiDump,
        table: &mut BTreeMap<String, Field>,
        class_name: &str,
    ) {
        let class = api.classes.iter().find(|c| c.name == class_name).unwrap();

        for member in &class.members {
            let (name, tags, field) = match &member {
                ApiMember::Callback { name, tags } => (
                    name,
                    tags,
                    Some(Field::from_field_kind(FieldKind::Property(
                        PropertyWritability::OverrideFields,
                    ))),
                ),

                ApiMember::Event { name, tags } => (
                    name,
                    tags,
                    Some(Field::from_field_kind(FieldKind::Struct(
                        "Event".to_owned(),
                    ))),
                ),

                ApiMember::Function {
                    name,
                    tags,
                    parameters,
                } => (
                    name,
                    tags,
                    Some(Field::from_field_kind(FieldKind::Function(
                        FunctionBehavior {
                            // TODO: Roblox doesn't tell us which parameters are nillable or not
                            // So results from these are regularly wrong
                            // The best solution is a manual patch for every method we *know* is nillable
                            // e.g. WaitForChild
                            // We can also let some parameters be required in the middle, and fix unused_variable to accept them

                            // arguments: parameters
                            // .iter()
                            // .map(|param| Argument {
                            // required: if param.default.is_some() {
                            // Required::NotRequired
                            // } else {
                            // Required::Required(None)
                            // },
                            // argument_type: match &param.parameter_type {
                            // ApiValueType::Class { name } => {
                            // ArgumentType::Display(name.to_owned())
                            // }
                            //
                            // ApiValueType::DataType { value } => match value {
                            // ApiDataType::Content => ArgumentType::String,
                            // ApiDataType::Other(other) => {
                            // ArgumentType::Display(other.to_owned())
                            // }
                            // },
                            //
                            // ApiValueType::Group { value } => match value {
                            // ApiGroupType::Table => ArgumentType::Table,
                            // ApiGroupType::Tuple => ArgumentType::Vararg,
                            // ApiGroupType::Variant => ArgumentType::Any,
                            // },
                            //
                            // ApiValueType::Primitive { value } => match value {
                            // ApiPrimitiveType::Bool => ArgumentType::Bool,
                            // ApiPrimitiveType::Double
                            // | ApiPrimitiveType::Float
                            // | ApiPrimitiveType::Int
                            // | ApiPrimitiveType::Int64 => ArgumentType::Number,
                            // ApiPrimitiveType::String => ArgumentType::String,
                            // },
                            //
                            // ApiValueType::Other { name } => {
                            // ArgumentType::Display(name.to_owned())
                            // }
                            // },
                            // })
                            // .collect(),
                            arguments: parameters
                                .iter()
                                .map(|_| Argument {
                                    argument_type: ArgumentType::Any,
                                    required: Required::NotRequired,
                                })
                                .collect(),
                            method: true,
                        },
                    ))),
                ),

                ApiMember::Property {
                    name,
                    tags,
                    security,
                    value_type,
                } => (name, tags, {
                    if *security == ApiPropertySecurity::default() {
                        let empty = Vec::new();
                        let tags: &Vec<String> = match tags {
                            Some(tags) => tags,
                            None => &empty,
                        };

                        let default_field = Some(Field::from_field_kind(FieldKind::Property(
                            if tags.contains(&"ReadOnly".to_string()) {
                                PropertyWritability::ReadOnly
                            } else {
                                PropertyWritability::OverrideFields
                            },
                        )));

                        match &value_type {
                            ApiValueType::Class { name } => {
                                self.write_class_struct(api, name);
                                Some(Field::from_field_kind(FieldKind::Struct(name.to_owned())))
                            }

                            ApiValueType::DataType { value } => {
                                // See comment on `has_custom_methods` for why we're taking
                                // such a lax approach here.
                                if value.has_custom_methods() {
                                    Some(Field::from_field_kind(FieldKind::Any))
                                } else {
                                    default_field
                                }
                            }

                            _ => default_field,
                        }
                    } else {
                        None
                    }
                }),
            };

            let empty = Vec::new();
            let tags: &Vec<String> = match tags {
                Some(tags) => tags,
                None => &empty,
            };

            if !self.show_deprecated && tags.contains(&"Deprecated".to_owned()) {
                continue;
            }

            if let Some(field) = field {
                table.insert(name.to_owned(), field);
            }
        }

        if class.superclass != "<<<ROOT>>>" {
            self.write_class_members(api, table, &class.superclass);
        }
    }

    fn write_enums(&mut self, api: &ApiDump) {
        for enuhm in &api.enums {
            self.std.globals.insert(
                format!("Enum.{}", enuhm.name),
                Field::from_field_kind(FieldKind::Struct("Enum".to_owned())),
            );

            for item in &enuhm.items {
                self.std.globals.insert(
                    format!("Enum.{}.{}", enuhm.name, item.name),
                    Field::from_field_kind(FieldKind::Struct("EnumItem".to_owned())),
                );
            }
        }
    }

    fn write_instance_new(&mut self, api: &ApiDump) {
        let instance_names = api
            .classes
            .iter()
            .filter_map(|class| {
                if !class.tags.contains(&"NotCreatable".to_owned()) {
                    Some(class.name.to_owned())
                } else {
                    None
                }
            })
            .collect();

        self.std.globals.insert(
            "Instance.new".to_owned(),
            Field::from_field_kind(FieldKind::Function(FunctionBehavior {
                arguments: vec![Argument {
                    argument_type: ArgumentType::Constant(instance_names),
                    required: Required::Required(None),
                }],
                method: false,
            })),
        );
    }

    fn write_get_service(&mut self, api: &ApiDump) {
        let service_names = api
            .classes
            .iter()
            .filter_map(|class| {
                if class.tags.contains(&"Service".to_owned()) {
                    Some(class.name.to_owned())
                } else {
                    None
                }
            })
            .collect();

        let data_model = self.std.structs.get_mut("DataModel").unwrap();

        *data_model.get_mut("GetService").unwrap() =
            Field::from_field_kind(FieldKind::Function(FunctionBehavior {
                arguments: vec![Argument {
                    argument_type: ArgumentType::Constant(service_names),
                    required: Required::Required(None),
                }],
                method: true,
            }));
    }

    fn deprecated_event_methods(&mut self) {
        if !self.show_deprecated {
            return;
        }

        let structs = &mut self.std.structs;
        let event_struct = structs.get_mut("Event").unwrap();
        let (connect, wait) = (
            event_struct["Connect"].clone(),
            event_struct["Wait"].clone(),
        );

        event_struct.insert("connect".to_owned(), connect);
        event_struct.insert("wait".to_owned(), wait);
    }
}
